# Agent Instructions for jax-js-bayes

## Project Overview

jax-js-bayes is a declarative Bayesian modeling library for jax-js.
It provides a TypeScript DSL for defining probabilistic models.

## Dependencies

This library depends on:
- **@jax-js/jax** - Array operations, autodiff
- **jax-js-mcmc** - HMC sampling (see companion repo)

Clone references:

```bash
git clone https://github.com/ekzhang/jax-js.git /tmp/jax-js
git clone https://github.com/StefanSko/jax-js-mcmc.git /tmp/jax-js-mcmc
```

Refer to /tmp/jax-js/src for:
- Array API conventions
- How grad/jit/vmap work
- Random number generation patterns

See `docs/JAX-JS-MEMORY.md` for jax-js move semantics and `.ref` usage patterns.

## Types and Conventions

- `JsTree<Array>` means any nested object/array structure whose leaves are jax-js `Array` values.
- `logProb(params)` must return a scalar (0-dim) `Array` in float32 (not a JS number).
- Tests assume float32 behavior (WebGPU/WASM); tolerances reflect this.

## Development Workflow

### TDD for Distributions and Constraints

Each distribution/constraint is developed test-first:

1. Write logProb test against analytical formula
2. Write sample test checking mean/std
3. Implement distribution
4. Tests pass

For constraints, also test:
- transform/inverse roundtrip
- logDetJacobian against numerical differentiation

### Integration Testing: posteriordb

**posteriordb is the gold standard for validating Bayesian inference correctness.** It provides reference posterior draws generated by Stan (the industry-standard sampler) for well-known statistical models.

#### Why posteriordb Matters

- **Ground truth**: Stan reference draws are the accepted correct answer
- **Correctness validation**: If our samples don't match Stan's, our inference is wrong
- **No shortcuts**: Unit tests verify components; posteriordb verifies the whole system works
- **Must pass before merge**: A PR cannot merge if posteriordb tests fail

#### Validation Methodology

- jax-js-bayes samples are compared against Stan reference draws
- Comparison metric: < 15% relative error on posterior means
- Tests use sufficient samples (8000+) to ensure stable estimates

#### Target Models (v1)

11 posteriordb models covering key distribution/constraint combinations:

| Model | Type | Validates |
|-------|------|-----------|
| Eight Schools (NC) | Hierarchical | Non-centered parameterization |
| Eight Schools (C) | Hierarchical | Centered parameterization |
| Kidscore Mom IQ | Linear regression | Normal likelihood |
| Radon Pooled | Pooled regression | Simple regression |
| Radon Hierarchical | Multi-level | Hierarchical indexing |
| Wells Distance | Logistic regression | BernoulliLogit |
| BLR | Matrix regression | Matrix operations |
| Log Earnings | Linear regression | Log transforms |
| Earnings Height | Linear regression | Wide priors |
| Kidscore Interaction | Linear regression | Interaction terms |
| Mesquite Log Volume | Linear regression | Multiple predictors |

#### Running posteriordb Tests

```bash
pnpm test tests/posteriordb
```

**Do not skip these tests.** They are the primary validation that the library produces correct inference results.

## Key Design Decisions

### Complete vs Predictive

The only type-level workflow enforcement. Keep it simple:

```typescript
type BoundModel<S extends "complete" | "predictive"> = { ... }
```

Don't add more workflow states - users manage their own workflow.

### Functional Composition

No special workflow functions. Just:
- `model.simulate(params)` - generate data
- `model.samplePrior()` - draw from prior
- `model.bind(data)` - bind data

Users compose these as needed.

### Observable Plot for Viz

Viz is optional. If user hasn't installed @observablehq/plot,
throw helpful error pointing to install command.

## Test Commands

Before running tests, install dependencies with `pnpm install`.

```bash
# Unit tests
pnpm test tests/distributions
pnpm test tests/constraints

# Integration tests
pnpm test tests/posteriordb

# All tests
pnpm test

# Browser tests
pnpm test:browser
```

## Code Style

- TypeScript strict mode
- Pure functions
- Match jax-js conventions
- Keep API surface small
